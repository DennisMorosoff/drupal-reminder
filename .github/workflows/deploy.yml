name: Deploy to Server

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Build application
        run: |
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
          echo "Building with version: $VERSION"
          echo "Build time: $BUILD_TIME"
          echo "Commit: $COMMIT"
          GOOS=linux GOARCH=amd64 go build -ldflags "-X main.version=$VERSION -X main.buildTime=$BUILD_TIME -X main.commitHash=$COMMIT" -o drupal-reminder-bot main.go

      - name: Check secrets are set
        run: |
          echo "Checking secrets..."
          if [ -z "${{ secrets.DEPLOY_HOST }}" ]; then
            echo "‚ùå DEPLOY_HOST is not set"
            exit 1
          else
            echo "‚úÖ DEPLOY_HOST is set"
          fi
          if [ -z "${{ secrets.DEPLOY_USER }}" ]; then
            echo "‚ùå DEPLOY_USER is not set"
            exit 1
          else
            echo "‚úÖ DEPLOY_USER is set"
          fi
          if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
            echo "‚ùå DEPLOY_SSH_KEY is not set"
            exit 1
          else
            echo "‚úÖ DEPLOY_SSH_KEY is set"
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–ª—é—á –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            mkdir -p ~/.ssh
            echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/test_key
            chmod 600 ~/.ssh/test_key
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞
            echo "=== SSH Key Format Check ==="
            if grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/test_key; then
              echo "‚úÖ Key format: OpenSSH private key (new format)"
            elif grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/test_key; then
              echo "‚úÖ Key format: RSA private key (old format)"
            elif grep -q "BEGIN EC PRIVATE KEY" ~/.ssh/test_key; then
              echo "‚úÖ Key format: EC private key"
            elif grep -q "BEGIN" ~/.ssh/test_key; then
              echo "‚ö†Ô∏è  Key format: Unknown BEGIN type"
              head -1 ~/.ssh/test_key
            else
              echo "‚ùå ERROR: Key does not appear to be a private key!"
              echo "First 100 chars: $(head -c 100 ~/.ssh/test_key)"
              echo "Key might be a PUBLIC key instead of PRIVATE key!"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –ù–ï –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á
            if grep -q "ssh-rsa\|ssh-ed25519\|ecdsa-sha2" ~/.ssh/test_key; then
              echo "‚ùå ERROR: This looks like a PUBLIC key, not a PRIVATE key!"
              echo "You need to use the PRIVATE key (id_rsa, id_ed25519, etc.)"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É –∫–ª—é—á–∞
            KEY_LENGTH=$(wc -c < ~/.ssh/test_key)
            echo "Key length: $KEY_LENGTH bytes"
            # ED25519 –∫–ª—é—á–∏ –∫–æ—Ä–æ—á–µ, —á–µ–º RSA, –ø–æ—ç—Ç–æ–º—É –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ-—Ä–∞–∑–Ω–æ–º—É
            if grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/test_key && [ "$KEY_LENGTH" -lt 400 ]; then
              echo "‚ö†Ô∏è  Warning: SSH key seems too short for ED25519 (should be >400 bytes)"
            elif grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/test_key && [ "$KEY_LENGTH" -lt 1000 ]; then
              echo "‚ö†Ô∏è  Warning: SSH key seems too short for RSA (should be >1000 bytes)"
            else
              echo "‚úÖ Key length is acceptable"
            fi
            
            # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –∏–∑ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ (–¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏)
            if ssh-keygen -y -f ~/.ssh/test_key > /tmp/test_key.pub 2>/dev/null; then
              echo "‚úÖ Key is valid and can generate public key"
              echo "Public key fingerprint:"
              ssh-keygen -lf /tmp/test_key.pub
              echo ""
              echo "=== IMPORTANT: Public key to add to server ==="
              echo "Add this public key to ~/.ssh/authorized_keys on the server:"
              echo "---"
              cat /tmp/test_key.pub
              echo "---"
              echo ""
              echo "On the server, run:"
              echo "  mkdir -p ~/.ssh"
              echo "  chmod 700 ~/.ssh"
              echo "  echo '$(cat /tmp/test_key.pub)' >> ~/.ssh/authorized_keys"
              echo "  chmod 600 ~/.ssh/authorized_keys"
            else
              echo "‚ùå ERROR: Cannot extract public key from private key!"
              echo "Key might be corrupted or in wrong format"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª—é—á –Ω–µ —Ç—Ä–µ–±—É–µ—Ç passphrase (–¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏)
            if grep -q "ENCRYPTED" ~/.ssh/test_key; then
              echo "‚ö†Ô∏è  Warning: Key appears to be encrypted with passphrase"
              echo "GitHub Actions cannot use encrypted keys without passphrase"
            fi
          fi
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            echo "‚ùå DEPLOY_PATH is not set"
            exit 1
          else
            echo "‚úÖ DEPLOY_PATH is set"
          fi

      - name: Pre-flight SSH connectivity checks
        run: |
          echo "=== Pre-flight SSH Connectivity Checks ==="
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: DNS —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
          echo "1Ô∏è‚É£  Checking DNS resolution for ${{ secrets.DEPLOY_HOST }}..."
          if host ${{ secrets.DEPLOY_HOST }} > /dev/null 2>&1; then
            IP_ADDRESS=$(host ${{ secrets.DEPLOY_HOST }} | grep -oP 'has address \K[0-9.]+' | head -1)
            echo "‚úÖ DNS resolution successful: ${{ secrets.DEPLOY_HOST }} -> $IP_ADDRESS"
          else
            echo "‚ùå DNS resolution failed for ${{ secrets.DEPLOY_HOST }}"
            echo "   Check if hostname is correct or DNS is configured properly"
            exit 1
          fi
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ö–æ—Å—Ç–∞ (ping)
          echo "2Ô∏è‚É£  Checking host reachability (ping)..."
          if ping -c 3 -W 5 ${{ secrets.DEPLOY_HOST }} > /dev/null 2>&1; then
            echo "‚úÖ Host is reachable via ping"
          else
            echo "‚ö†Ô∏è  Host is not responding to ping (may be normal if ICMP is blocked)"
            echo "   Will continue with SSH port check..."
          fi
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 3: –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å SSH –ø–æ—Ä—Ç–∞ (22)
          echo "3Ô∏è‚É£  Checking SSH port (22) accessibility..."
          if timeout 5 bash -c "echo > /dev/tcp/${{ secrets.DEPLOY_HOST }}/22" 2>/dev/null; then
            echo "‚úÖ SSH port 22 is open and accessible"
          else
            echo "‚ùå SSH port 22 is not accessible!"
            echo ""
            echo "üîß Possible causes:"
            echo "   - SSH service is not running on the server"
            echo "   - Firewall is blocking port 22"
            echo "   - Server is using a different SSH port"
            echo "   - Network connectivity issues"
            echo ""
            echo "To check on server:"
            echo "   sudo systemctl status ssh"
            echo "   sudo netstat -tlnp | grep :22"
            echo "   sudo ufw status (if using UFW)"
            echo "   sudo iptables -L -n (if using iptables)"
            exit 1
          fi
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –ø–æ—Ä—Ç–æ–≤ SSH
          echo "4Ô∏è‚É£  Checking for SSH on common alternative ports..."
          for port in 2222 2200 22022; do
            if timeout 2 bash -c "echo > /dev/tcp/${{ secrets.DEPLOY_HOST }}/$port" 2>/dev/null; then
              echo "‚ö†Ô∏è  Port $port is also open (might be SSH on alternative port)"
            fi
          done
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 5: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ SSH –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
          echo "5Ô∏è‚É£  Checking SSH server version..."
          SSH_VERSION=$(timeout 5 ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} 2>&1 | \
            grep -i "SSH-" | head -1 || echo "Could not determine")
          if [ "$SSH_VERSION" != "Could not determine" ]; then
            echo "‚úÖ SSH server version: $SSH_VERSION"
          else
            echo "‚ö†Ô∏è  Could not determine SSH server version"
          fi
          echo ""
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ 6: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Ö–æ—Å—Ç–∞ (IP vs hostname)
          echo "6Ô∏è‚É£  Validating host format..."
          HOST="${{ secrets.DEPLOY_HOST }}"
          if [[ $HOST =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "‚úÖ Host is an IP address: $HOST"
          else
            echo "‚úÖ Host is a hostname: $HOST"
          fi
          echo ""

      - name: Test SSH connection with verbose output
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/test_key
          chmod 600 ~/.ssh/test_key
          
          echo "=== Testing SSH connection with verbose output ==="
          SSH_OUTPUT=$(ssh -vvv -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -o ServerAliveInterval=5 \
              -o ServerAliveCountMax=3 \
              -i ~/.ssh/test_key \
              ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
              "echo 'SSH connection successful!'" 2>&1) || SSH_FAILED=true
          
          echo "$SSH_OUTPUT"
          
          echo ""
          echo "=== SSH Connection Analysis ==="
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫
          if echo "$SSH_OUTPUT" | grep -q "Connection refused"; then
            echo "‚ùå Connection refused - SSH service may not be running"
            echo ""
            echo "üîß SOLUTION: Start SSH service on server"
            echo "   sudo systemctl start ssh"
            echo "   sudo systemctl enable ssh"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Connection timed out"; then
            echo "‚ùå Connection timed out - network or firewall issue"
            echo ""
            echo "üîß POSSIBLE SOLUTIONS:"
            echo "   1. Check firewall rules on server"
            echo "   2. Verify server is accessible from internet"
            echo "   3. Check if SSH is listening on correct port"
            echo "   4. Verify security group rules (if using cloud provider)"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Host key verification failed"; then
            echo "‚ùå Host key verification failed"
            echo "   This should not happen with StrictHostKeyChecking=no"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Could not resolve hostname"; then
            echo "‚ùå Could not resolve hostname - DNS issue"
            echo ""
            echo "üîß SOLUTION: Check hostname spelling or DNS configuration"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "No route to host"; then
            echo "‚ùå No route to host - network routing issue"
            echo ""
            echo "üîß POSSIBLE SOLUTIONS:"
            echo "   1. Check network connectivity"
            echo "   2. Verify server IP address"
            echo "   3. Check routing tables"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Offering public key"; then
            echo "‚úÖ Key is being offered to server"
            KEY_FINGERPRINT=$(echo "$SSH_OUTPUT" | grep "Offering public key" | grep -o "SHA256:[^ ]*" | head -1)
            echo "   Key fingerprint: $KEY_FINGERPRINT"
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Permission denied"; then
            echo "‚ùå Permission denied - key was rejected by server"
            echo ""
            echo "üîß SOLUTION: Add the public key to server's authorized_keys"
            echo ""
            echo "Extracting public key from private key:"
            echo "---"
            PUB_KEY=$(ssh-keygen -y -f ~/.ssh/test_key)
            echo "$PUB_KEY"
            echo "---"
            echo ""
            echo "On your server, run these commands:"
            echo "  mkdir -p ~/.ssh"
            echo "  chmod 700 ~/.ssh"
            echo "  echo '$PUB_KEY' >> ~/.ssh/authorized_keys"
            echo "  chmod 600 ~/.ssh/authorized_keys"
            echo ""
            echo "Then verify with:"
            echo "  cat ~/.ssh/authorized_keys"
            echo "  ls -la ~/.ssh/"
            echo ""
            echo "Expected output for ls -la ~/.ssh/:"
            echo "  drwx------ 2 user user 4096 ... ."
            echo "  -rw------- 1 user user  ... authorized_keys"
            echo ""
            echo "Also check server SSH logs:"
            echo "  sudo tail -f /var/log/auth.log"
            echo "  # or on some systems:"
            echo "  sudo journalctl -u ssh -f"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Too many authentication failures"; then
            echo "‚ùå Too many authentication failures"
            echo ""
            echo "üîß SOLUTION: Server is rejecting too many key attempts"
            echo "   This might happen if you have many keys in ssh-agent"
            echo "   Try using IdentitiesOnly=yes in SSH config"
            exit 1
          fi
          
          if echo "$SSH_OUTPUT" | grep -q "Authentication failed"; then
            echo "‚ùå Authentication failed"
            echo ""
            echo "üîß POSSIBLE SOLUTIONS:"
            echo "   1. Verify username is correct: ${{ secrets.DEPLOY_USER }}"
            echo "   2. Check if public key is in authorized_keys on server"
            echo "   3. Verify key permissions on server (600 for authorized_keys)"
            echo "   4. Check server SSH configuration (PubkeyAuthentication yes)"
            exit 1
          fi
          
          if [ -z "$SSH_FAILED" ]; then
            echo "‚úÖ SSH connection successful!"
          else
            echo "‚ùå SSH connection failed with unknown error"
            echo ""
            echo "üîß DEBUGGING STEPS:"
            echo "   1. Check server SSH logs: sudo tail -f /var/log/auth.log"
            echo "   2. Verify SSH service is running: sudo systemctl status ssh"
            echo "   3. Check SSH config: sudo cat /etc/ssh/sshd_config | grep -E 'PubkeyAuthentication|PasswordAuthentication|PermitRootLogin'"
            echo "   4. Test connection manually from your local machine"
            exit 1
          fi

      - name: Test SSH connection
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            echo "‚úÖ SSH connection successful!"
            echo "Hostname: $(hostname)"
            echo "User: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "Testing write permissions..."
            touch /tmp/github-actions-test && rm /tmp/github-actions-test && echo "‚úÖ Write permissions OK" || echo "‚ùå Write permissions failed"

      - name: Check SSH server configuration (sshd_config)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: 22
          timeout: 30s
          command_timeout: 10m
          script: |
            set +e  # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö (—Ö–æ—Ç–∏–º —É–≤–∏–¥–µ—Ç—å –≤—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏)
            set -u  # –ü—Ä–µ—Ä—ã–≤–∞—Ç—å –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            
            echo "=== SSH Server Configuration Check (sshd_config) ==="
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ sudo (–µ—Å–ª–∏ –Ω—É–∂–µ–Ω)
            SUDO_AVAILABLE=false
            if command -v sudo >/dev/null 2>&1; then
              if sudo -n true 2>/dev/null; then
                SUDO_AVAILABLE=true
                echo "‚úÖ Sudo –¥–æ—Å—Ç—É–ø–µ–Ω –±–µ–∑ –ø–∞—Ä–æ–ª—è"
              else
                echo "‚ö†Ô∏è  Sudo –¥–æ—Å—Ç—É–ø–µ–Ω, –Ω–æ –º–æ–∂–µ—Ç —Ç—Ä–µ–±–æ–≤–∞—Ç—å –ø–∞—Ä–æ–ª—å"
              fi
            else
              echo "‚ÑπÔ∏è  Sudo –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥—ã –±–µ–∑ sudo"
            fi
            echo ""
            
            # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞—á–µ–Ω–∏–π –≤ sshd_config
            check_sshd_config() {
              local key=$1
              local expected_value=$2
              local config_file="/etc/ssh/sshd_config"
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
              if [ ! -f "$config_file" ]; then
                echo "‚ùå SSH config file not found: $config_file"
                return 1
              fi
              
              # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª –±–µ–∑ sudo, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - —Å sudo
              local grep_cmd="grep"
              if [ ! -r "$config_file" ]; then
                if command -v sudo >/dev/null 2>&1; then
                  grep_cmd="sudo grep"
                else
                  echo "   ‚ö†Ô∏è  Cannot read $config_file (no sudo access)"
                  return 1
                fi
              fi
              
              # –ò—â–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ (—É—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏)
              local actual_value=$($grep_cmd -i "^[^#]*$key" "$config_file" 2>/dev/null | tail -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
              
              if [ -z "$actual_value" ]; then
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
                local commented_value=$($grep_cmd -i "^#.*$key" "$config_file" 2>/dev/null | tail -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
                if [ -n "$commented_value" ]; then
                  actual_value="$commented_value (default, commented)"
                else
                  actual_value="not found (using default)"
                fi
              fi
              
              echo -n "   $key: $actual_value"
              
              # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –æ–∂–∏–¥–∞–µ–º—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
              if [ -n "$expected_value" ]; then
                if echo "$actual_value" | grep -qi "^$expected_value"; then
                  echo " ‚úÖ"
                  return 0
                else
                  echo " ‚ö†Ô∏è  (expected: $expected_value)"
                  return 1
                fi
              else
                echo ""
                return 0
              fi
            }
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: PubkeyAuthentication
            echo "1Ô∏è‚É£  Checking PubkeyAuthentication..."
            if check_sshd_config "PubkeyAuthentication" "yes"; then
              echo "   ‚úÖ Public key authentication is enabled"
            else
              echo "   ‚ùå Public key authentication might be disabled!"
              echo "   üîß To fix, add to /etc/ssh/sshd_config:"
              echo "      PubkeyAuthentication yes"
              echo "   Then restart SSH: sudo systemctl restart ssh"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: PasswordAuthentication (–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω)
            echo "2Ô∏è‚É£  Checking PasswordAuthentication..."
            if check_sshd_config "PasswordAuthentication" "no"; then
              echo "   ‚úÖ Password authentication is disabled (recommended for security)"
            else
              echo "   ‚ö†Ô∏è  Password authentication is enabled (security risk)"
              echo "   üí° Consider disabling it: PasswordAuthentication no"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 3: AuthorizedKeysFile
            echo "3Ô∏è‚É£  Checking AuthorizedKeysFile path..."
            # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –±–µ–∑ sudo, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - —Å sudo
            if [ -r "/etc/ssh/sshd_config" ]; then
              AUTHORIZED_KEYS_PATH=$(grep -i "^[^#]*AuthorizedKeysFile" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            elif command -v sudo >/dev/null 2>&1; then
              AUTHORIZED_KEYS_PATH=$(sudo grep -i "^[^#]*AuthorizedKeysFile" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            else
              AUTHORIZED_KEYS_PATH=""
            fi
            if [ -z "$AUTHORIZED_KEYS_PATH" ]; then
              AUTHORIZED_KEYS_PATH="~/.ssh/authorized_keys (default)"
            fi
            echo "   AuthorizedKeysFile: $AUTHORIZED_KEYS_PATH"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ authorized_keys —Ñ–∞–π–ª–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            USER_HOME=$(eval echo ~$USER)
            ACTUAL_AUTH_KEYS="$USER_HOME/.ssh/authorized_keys"
            if [ -f "$ACTUAL_AUTH_KEYS" ]; then
              echo "   ‚úÖ authorized_keys file exists: $ACTUAL_AUTH_KEYS"
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ñ–∞–π–ª
              FILE_PERMS=$(stat -c "%a" "$ACTUAL_AUTH_KEYS" 2>/dev/null || stat -f "%OLp" "$ACTUAL_AUTH_KEYS" 2>/dev/null)
              if [ "$FILE_PERMS" = "600" ] || [ "$FILE_PERMS" = "644" ]; then
                echo "   ‚úÖ File permissions: $FILE_PERMS (acceptable)"
              else
                echo "   ‚ö†Ô∏è  File permissions: $FILE_PERMS (should be 600 or 644)"
                echo "   üîß To fix: chmod 600 $ACTUAL_AUTH_KEYS"
              fi
            else
              echo "   ‚ùå authorized_keys file not found: $ACTUAL_AUTH_KEYS"
              echo "   üîß Create it with:"
              echo "      mkdir -p $USER_HOME/.ssh"
              echo "      chmod 700 $USER_HOME/.ssh"
              echo "      touch $ACTUAL_AUTH_KEYS"
              echo "      chmod 600 $ACTUAL_AUTH_KEYS"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 4: PermitRootLogin
            echo "4Ô∏è‚É£  Checking PermitRootLogin..."
            if check_sshd_config "PermitRootLogin" "no"; then
              echo "   ‚úÖ Root login is disabled (recommended for security)"
            else
              # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –±–µ–∑ sudo, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - —Å sudo
              if [ -r "/etc/ssh/sshd_config" ]; then
                ROOT_LOGIN_VALUE=$(grep -i "^[^#]*PermitRootLogin" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
              elif command -v sudo >/dev/null 2>&1; then
                ROOT_LOGIN_VALUE=$(sudo grep -i "^[^#]*PermitRootLogin" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
              else
                ROOT_LOGIN_VALUE=""
              fi
              if [ "$ROOT_LOGIN_VALUE" = "prohibit-password" ] || [ "$ROOT_LOGIN_VALUE" = "prohibit-password (default, commented)" ]; then
                echo "   ‚ö†Ô∏è  Root login with password disabled, but key-based login allowed"
              else
                echo "   ‚ö†Ô∏è  Root login is enabled (security risk)"
                echo "   üí° Consider setting: PermitRootLogin no"
              fi
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 5: PermitEmptyPasswords
            echo "5Ô∏è‚É£  Checking PermitEmptyPasswords..."
            if check_sshd_config "PermitEmptyPasswords" "no"; then
              echo "   ‚úÖ Empty passwords are disabled"
            else
              echo "   ‚ùå Empty passwords are enabled (security risk!)"
              echo "   üîß To fix: PermitEmptyPasswords no"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 6: MaxAuthTries
            echo "6Ô∏è‚É£  Checking MaxAuthTries..."
            # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –±–µ–∑ sudo, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - —Å sudo
            if [ -r "/etc/ssh/sshd_config" ]; then
              MAX_AUTH_TRIES=$(grep -i "^[^#]*MaxAuthTries" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            elif command -v sudo >/dev/null 2>&1; then
              MAX_AUTH_TRIES=$(sudo grep -i "^[^#]*MaxAuthTries" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            else
              MAX_AUTH_TRIES=""
            fi
            if [ -z "$MAX_AUTH_TRIES" ]; then
              MAX_AUTH_TRIES="6 (default)"
            fi
            echo "   MaxAuthTries: $MAX_AUTH_TRIES"
            if [ "$MAX_AUTH_TRIES" -lt 10 ] 2>/dev/null; then
              echo "   ‚úÖ Reasonable limit for brute force protection"
            else
              echo "   ‚ö†Ô∏è  High limit might allow more brute force attempts"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 7: LogLevel
            echo "7Ô∏è‚É£  Checking LogLevel..."
            # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –±–µ–∑ sudo, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - —Å sudo
            if [ -r "/etc/ssh/sshd_config" ]; then
              LOG_LEVEL=$(grep -i "^[^#]*LogLevel" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            elif command -v sudo >/dev/null 2>&1; then
              LOG_LEVEL=$(sudo grep -i "^[^#]*LogLevel" /etc/ssh/sshd_config 2>/dev/null | tail -1 | awk '{print $2}')
            else
              LOG_LEVEL=""
            fi
            if [ -z "$LOG_LEVEL" ]; then
              LOG_LEVEL="INFO (default)"
            fi
            echo "   LogLevel: $LOG_LEVEL"
            if echo "$LOG_LEVEL" | grep -qi "info\|verbose\|debug"; then
              echo "   ‚úÖ Sufficient logging level for debugging"
            else
              echo "   ‚ö†Ô∏è  Lower logging level might make debugging harder"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 8: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –Ω–∞ .ssh –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
            echo "8Ô∏è‚É£  Checking .ssh directory permissions..."
            if [ -d "$USER_HOME/.ssh" ]; then
              SSH_DIR_PERMS=$(stat -c "%a" "$USER_HOME/.ssh" 2>/dev/null || stat -f "%OLp" "$USER_HOME/.ssh" 2>/dev/null)
              echo "   Directory: $USER_HOME/.ssh"
              echo "   Permissions: $SSH_DIR_PERMS"
              if [ "$SSH_DIR_PERMS" = "700" ]; then
                echo "   ‚úÖ Directory permissions are correct (700)"
              else
                echo "   ‚ö†Ô∏è  Directory permissions should be 700"
                echo "   üîß To fix: chmod 700 $USER_HOME/.ssh"
              fi
            else
              echo "   ‚ùå .ssh directory not found: $USER_HOME/.ssh"
              echo "   üîß Create it with: mkdir -p $USER_HOME/.ssh && chmod 700 $USER_HOME/.ssh"
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 9: –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –¥–æ–±–∞–≤–ª–µ–Ω –≤ authorized_keys
            echo "9Ô∏è‚É£  Checking if GitHub Actions public key is in authorized_keys..."
            if [ -f "$ACTUAL_AUTH_KEYS" ]; then
              # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –∏–∑ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ (–µ—Å–ª–∏ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø)
              # –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª –Ω–µ –ø—É—Å—Ç–æ–π
              KEY_COUNT=$(grep -c "ssh-" "$ACTUAL_AUTH_KEYS" 2>/dev/null || echo "0")
              if [ "$KEY_COUNT" -gt 0 ]; then
                echo "   ‚úÖ Found $KEY_COUNT SSH public key(s) in authorized_keys"
                echo "   üí° Make sure GitHub Actions public key is included"
              else
                echo "   ‚ùå No SSH keys found in authorized_keys file"
                echo "   üîß Add your public key to: $ACTUAL_AUTH_KEYS"
              fi
            fi
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ 10: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è SSH —Å–µ—Ä–≤–∏—Å–∞
            echo "üîü Checking SSH service status..."
            if systemctl is-active --quiet ssh || systemctl is-active --quiet sshd; then
              echo "   ‚úÖ SSH service is running"
              SSH_SERVICE=$(systemctl is-active ssh 2>/dev/null && echo "ssh" || echo "sshd")
              echo "   Service name: $SSH_SERVICE"
            else
              echo "   ‚ùå SSH service is not running!"
              echo "   üîß Start it with: sudo systemctl start ssh (or sshd)"
            fi
            echo ""
            
            echo "=== SSH Configuration Check Complete ==="
            echo ""
            echo "üí° To view full sshd_config:"
            if [ -r "/etc/ssh/sshd_config" ]; then
              echo "   cat /etc/ssh/sshd_config"
            elif [ "$SUDO_AVAILABLE" = "true" ]; then
              echo "   sudo cat /etc/ssh/sshd_config"
            else
              echo "   (requires sudo or root access)"
            fi
            echo ""
            echo "üí° To test SSH config without restarting:"
            if [ "$SUDO_AVAILABLE" = "true" ]; then
              echo "   sudo sshd -t"
            else
              echo "   (requires sudo access)"
            fi
            echo ""
            echo "üí° To apply changes and restart SSH:"
            if [ "$SUDO_AVAILABLE" = "true" ]; then
              echo "   sudo systemctl restart ssh (or sshd)"
            else
              echo "   (requires sudo access)"
            fi
            echo ""
            echo "‚úÖ SSH configuration check finished successfully"

      - name: Copy binary to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          source: "drupal-reminder-bot"
          target: ${{ secrets.DEPLOY_PATH }}
          strip_components: 0
          debug: true
          timeout: 30s

      - name: Stop old process and start new one
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          command_timeout: 60s
          script: |
            set -x  # –í–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥
            set -e  # –ü—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ (–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º || true –≥–¥–µ –Ω—É–∂–Ω–æ)
            
            echo "=========================================="
            echo "=== –î–ï–¢–ê–õ–¨–ù–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–ï–ü–õ–û–Ø ==="
            echo "=========================================="
            echo ""
            
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
            echo "=== –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û–ë –û–ö–†–£–ñ–ï–ù–ò–ò ==="
            echo "USER: $USER"
            echo "HOME: $HOME"
            echo "PWD: $(pwd)"
            echo "SHELL: $SHELL"
            echo "PATH: $PATH"
            echo "SSH_CONNECTION: ${SSH_CONNECTION:-not set}"
            echo "SSH_CLIENT: ${SSH_CLIENT:-not set}"
            echo "SSH_TTY: ${SSH_TTY:-not set}"
            echo ""
            
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            echo "=== –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø ==="
            echo "Hostname: $(hostname)"
            echo "Uptime: $(uptime)"
            echo "Kernel: $(uname -a)"
            echo "Available memory:"
            free -h || true
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
            echo "=== –î–û–°–¢–£–ü–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´ ==="
            echo "screen: $(command -v screen || echo 'not found')"
            echo "tmux: $(command -v tmux || echo 'not found')"
            echo "at: $(command -v at || echo 'not found')"
            echo "nohup: $(command -v nohup || echo 'not found')"
            echo "setsid: $(command -v setsid || echo 'not found')"
            echo "systemd: $(command -v systemctl || echo 'not found')"
            echo ""
            
            # Expand ~ to absolute path if needed (works with both ~/path and absolute paths)
            echo "=== –†–ê–°–®–ò–†–ï–ù–ò–ï –ü–£–¢–ò –î–ï–ü–õ–û–Ø ==="
            DEPLOY_PATH_EXPANDED=$(eval echo "${{ secrets.DEPLOY_PATH }}")
            echo "Original path: ${{ secrets.DEPLOY_PATH }}"
            echo "Expanded path: $DEPLOY_PATH_EXPANDED"
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if [ ! -d "$DEPLOY_PATH_EXPANDED" ]; then
              echo "‚ùå ERROR: Deployment directory does not exist: $DEPLOY_PATH_EXPANDED"
              exit 1
            fi
            echo "‚úÖ Directory exists"
            echo "Directory permissions: $(ls -ld "$DEPLOY_PATH_EXPANDED")"
            echo ""
            
            cd "$DEPLOY_PATH_EXPANDED"
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -lah || true
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
            echo "=== –ü–†–û–í–ï–†–ö–ê –ë–ò–ù–ê–†–ù–û–ì–û –§–ê–ô–õ–ê ==="
            if [ ! -f "./drupal-reminder-bot" ]; then
              echo "‚ùå ERROR: Binary file drupal-reminder-bot not found!"
              echo "Files in directory:"
              ls -lah
              exit 1
            fi
            echo "‚úÖ Binary file exists"
            echo "File info:"
            ls -lah ./drupal-reminder-bot
            file ./drupal-reminder-bot || true
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—É—â–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            echo "=== –¢–ï–ö–£–©–ò–ï –ü–†–û–¶–ï–°–°–´ drupal-reminder-bot ==="
            PROC_PATTERN='^[^ ]*/drupal-reminder-bot($| )'
            OLD_PID=""
            if pgrep -f "$PROC_PATTERN" > /dev/null; then
              echo "Found existing processes:"
              ps aux | grep -E "[d]rupal-reminder-bot" || true
              # –°–æ—Ö—Ä–∞–Ω—è–µ–º PID –ø–µ—Ä–≤–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
              OLD_PID=$(pgrep -f "$PROC_PATTERN" | head -1)
              echo "Old process PID: $OLD_PID"
              pgrep -f "$PROC_PATTERN" | xargs ps -fp 2>/dev/null || true
            else
              echo "No existing processes found"
            fi
            echo ""
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É PID
            echo "=== –û–°–¢–ê–ù–û–í–ö–ê –°–¢–ê–†–û–ì–û –ü–†–û–¶–ï–°–°–ê ==="
            if [ -n "$OLD_PID" ]; then
              echo "Stopping old process with PID: $OLD_PID"
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
              if kill -0 "$OLD_PID" 2>/dev/null; then
                echo "Sending SIGTERM to PID $OLD_PID..."
                kill "$OLD_PID" 2>/dev/null || true
                sleep 2
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è –ª–∏ –ø—Ä–æ—Ü–µ—Å—Å
                if kill -0 "$OLD_PID" 2>/dev/null; then
                  echo "‚ö†Ô∏è  Process still running, force killing with SIGKILL..."
                  kill -9 "$OLD_PID" 2>/dev/null || true
                  sleep 1
                  
                  # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
                  if kill -0 "$OLD_PID" 2>/dev/null; then
                    echo "‚ùå ERROR: Failed to kill process with PID $OLD_PID!"
                    ps aux | grep -E "[d]rupal-reminder" || true
                    exit 1
                  fi
                fi
                echo "‚úÖ Old process (PID $OLD_PID) stopped successfully"
              else
                echo "Process with PID $OLD_PID no longer exists"
              fi
            else
              echo "No old process to stop"
            fi
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
            sleep 1
            REMAINING_PIDS=$(pgrep -f "$PROC_PATTERN" 2>/dev/null || echo "")
            if [ -n "$REMAINING_PIDS" ]; then
              echo "‚ö†Ô∏è  Warning: Found remaining processes: $REMAINING_PIDS"
              echo "This might be from screen/tmux sessions, will be handled during startup"
            fi
            echo ""
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            echo "=== –£–°–¢–ê–ù–û–í–ö–ê –ü–†–ê–í –ù–ê –í–´–ü–û–õ–ù–ï–ù–ò–ï ==="
            chmod +x drupal-reminder-bot
            echo "File permissions after chmod:"
            ls -lah ./drupal-reminder-bot
            echo ""
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ .env —Ñ–∞–π–ª–∞ –î–û –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
            echo "=== –ü–†–û–í–ï–†–ö–ê –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò ==="
            ENV_CHECK_FAILED=false
            if [ -f ".env" ]; then
              echo "‚úÖ .env file exists"
              echo "File permissions: $(ls -lah .env | awk '{print $1, $3, $4}')"
              echo "File size: $(stat -c%s .env 2>/dev/null || stat -f%z .env 2>/dev/null) bytes"
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (–±–µ–∑ –≤—ã–≤–æ–¥–∞ –∑–Ω–∞—á–µ–Ω–∏–π)
              if grep -q "TELEGRAM_BOT_TOKEN" .env; then
                echo "‚úÖ TELEGRAM_BOT_TOKEN found in .env"
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –Ω–µ –ø—É—Å—Ç–æ–π
                if grep -q "^TELEGRAM_BOT_TOKEN=\s*$" .env || grep -q "^TELEGRAM_BOT_TOKEN=\"\"" .env || grep -q "^TELEGRAM_BOT_TOKEN=''" .env; then
                  echo "‚ùå ERROR: TELEGRAM_BOT_TOKEN is empty in .env file!"
                  ENV_CHECK_FAILED=true
                fi
              else
                echo "‚ùå ERROR: TELEGRAM_BOT_TOKEN not found in .env"
                ENV_CHECK_FAILED=true
              fi
            else
              echo "‚ùå ERROR: .env file not found!"
              echo "The bot requires .env file with TELEGRAM_BOT_TOKEN to run."
              ENV_CHECK_FAILED=true
            fi
            
            # –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ –ø—Ä–æ—à–ª–∞, –ø—Ä–µ—Ä—ã–≤–∞–µ–º –¥–µ–ø–ª–æ–π
            if [ "$ENV_CHECK_FAILED" = "true" ]; then
              echo ""
              echo "‚ùå‚ùå‚ùå CONFIGURATION ERROR ‚ùå‚ùå‚ùå"
              echo "Cannot start process without proper configuration."
              echo "Please ensure .env file exists and contains valid TELEGRAM_BOT_TOKEN"
              exit 1
            fi
            echo ""
            
            # –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
            echo "=== –ó–ê–ü–£–°–ö –ü–†–û–¶–ï–°–°–ê ==="
            START_METHOD=""
            NEW_PID=""  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è PID –Ω–æ–≤–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –ª–æ–≥–∏ –≤–º–µ—Å—Ç–æ –æ—á–∏—Å—Ç–∫–∏
            if [ -f "bot.log" ]; then
              echo "Saving old bot.log to bot.log.old..."
              mv bot.log bot.log.old || true
              echo "‚úÖ Old log saved"
            fi
            
            # –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å screen –¥–ª—è –∑–∞–ø—É—Å–∫–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
            if command -v screen > /dev/null 2>&1; then
              START_METHOD="screen"
              echo "Using screen for process isolation..."
              SCREEN_EXIT_CODE=0
              screen -dmS drupal-reminder bash -c "cd '$DEPLOY_PATH_EXPANDED' && exec ./drupal-reminder-bot > bot.log 2>&1" 2>&1 | tee -a deploy.log || SCREEN_EXIT_CODE=$?
              echo "Screen command executed, exit code: $SCREEN_EXIT_CODE"
              sleep 3
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ screen —Å–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞
              if screen -list | grep -q drupal-reminder; then
                echo "‚úÖ Screen session created successfully"
                screen -list
                # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å PID –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–∑ screen
                SCREEN_PID=$(screen -list | grep drupal-reminder | awk -F'.' '{print $1}' | awk '{print $1}' | head -1)
                if [ -n "$SCREEN_PID" ]; then
                  # –ü–æ–ª—É—á–∞–µ–º PID —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                  NEW_PID=$(pgrep -P "$SCREEN_PID" | head -1 || pgrep -f "$PROC_PATTERN" | head -1)
                  if [ -n "$NEW_PID" ]; then
                    echo "New process PID: $NEW_PID"
                  fi
                fi
              else
                echo "‚ö†Ô∏è  Screen session not found in list"
                screen -list || true
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏ —Å—Ä–∞–∑—É, –µ—Å–ª–∏ —Å–µ—Å—Å–∏—è –Ω–µ —Å–æ–∑–¥–∞–Ω–∞
                if [ -f "bot.log" ]; then
                  echo "Checking bot.log for errors:"
                  cat bot.log || tail -50 bot.log
                  if grep -qiE "error|panic|fatal|failed" bot.log; then
                    echo "‚ùå Errors found in logs - process may have failed to start"
                  fi
                fi
                if [ "$SCREEN_EXIT_CODE" != "0" ]; then
                  echo "‚ö†Ô∏è  Screen command exited with non-zero code: $SCREEN_EXIT_CODE"
                fi
              fi
            # –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å tmux (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
            elif command -v tmux > /dev/null 2>&1; then
              START_METHOD="tmux"
              echo "Using tmux for process isolation..."
              TMUX_EXIT_CODE=0
              tmux new-session -d -s drupal-reminder "cd '$DEPLOY_PATH_EXPANDED' && exec ./drupal-reminder-bot > bot.log 2>&1" 2>&1 | tee -a deploy.log || TMUX_EXIT_CODE=$?
              echo "Tmux command executed, exit code: $TMUX_EXIT_CODE"
              sleep 3
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ tmux —Å–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞
              if tmux list-sessions 2>/dev/null | grep -q drupal-reminder; then
                echo "‚úÖ Tmux session created successfully"
                tmux list-sessions
                # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å PID –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–∑ tmux
                TMUX_PID=$(tmux list-sessions -F "#{session_name} #{pane_pid}" 2>/dev/null | grep drupal-reminder | awk '{print $2}' | head -1)
                if [ -n "$TMUX_PID" ]; then
                  NEW_PID=$(pgrep -P "$TMUX_PID" | head -1 || pgrep -f "$PROC_PATTERN" | head -1)
                  if [ -n "$NEW_PID" ]; then
                    echo "New process PID: $NEW_PID"
                  fi
                fi
              else
                echo "‚ö†Ô∏è  Tmux session not found in list"
                tmux list-sessions || true
                if [ -f "bot.log" ]; then
                  echo "Checking bot.log for errors:"
                  tail -50 bot.log || cat bot.log
                  if grep -qiE "error|panic|fatal|failed" bot.log; then
                    echo "‚ùå Errors found in logs - process may have failed to start"
                  fi
                fi
                if [ "$TMUX_EXIT_CODE" != "0" ]; then
                  echo "‚ö†Ô∏è  Tmux command exited with non-zero code: $TMUX_EXIT_CODE"
                fi
              fi
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º at –¥–ª—è –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
            elif command -v at > /dev/null 2>&1; then
              START_METHOD="at"
              echo "Using at for delayed start..."
              AT_EXIT_CODE=0
              echo "cd '$DEPLOY_PATH_EXPANDED' && nohup ./drupal-reminder-bot > bot.log 2>&1 &" | at now 2>&1 | tee -a deploy.log || AT_EXIT_CODE=$?
              echo "At command executed, exit code: $AT_EXIT_CODE"
              sleep 3
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥—å at
              atq || true
              # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å PID –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ —á–µ—Ä–µ–∑ at
              NEW_PID=$(pgrep -f "$PROC_PATTERN" | head -1)
              if [ -n "$NEW_PID" ]; then
                echo "New process PID: $NEW_PID"
              fi
              if [ "$AT_EXIT_CODE" != "0" ]; then
                echo "‚ö†Ô∏è  At command exited with non-zero code: $AT_EXIT_CODE"
              fi
            # –§–∏–Ω–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç: –∏—Å–ø–æ–ª—å–∑—É–µ–º nohup —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –æ—Ç–≤—è–∑—ã–≤–∞–Ω–∏–µ–º
            else
              START_METHOD="nohup"
              echo "Using nohup with full process isolation..."
              echo "Command: (cd \"$DEPLOY_PATH_EXPANDED\" && nohup ./drupal-reminder-bot > bot.log 2>&1 < /dev/null &)"
              # –ó–∞–ø—É—Å–∫–∞–µ–º —á–µ—Ä–µ–∑ –æ—Ç–¥–µ–ª—å–Ω—É—é –æ–±–æ–ª–æ—á–∫—É —Å –ø–æ–ª–Ω—ã–º –æ—Ç–≤—è–∑—ã–≤–∞–Ω–∏–µ–º
              (cd "$DEPLOY_PATH_EXPANDED" && nohup ./drupal-reminder-bot > bot.log 2>&1 < /dev/null &)
              NOHUP_PID=$!
              echo "Nohup command executed, background PID: $NOHUP_PID"
              # –ò—Å–ø–æ–ª—å–∑—É–µ–º PID –æ–±–æ–ª–æ—á–∫–∏ –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É –ø–æ–∏—Å–∫–∞
              NEW_PID=$(pgrep -P "$NOHUP_PID" | head -1 || pgrep -f "$PROC_PATTERN" | head -1)
              if [ -n "$NEW_PID" ]; then
                echo "New process PID: $NEW_PID"
              fi
              sleep 4
            fi
            
            echo "Start method used: $START_METHOD"
            if [ -n "$NEW_PID" ]; then
              echo "New process PID from startup: $NEW_PID"
            fi
            echo ""
            
            # –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
            echo "=== –ü–†–û–í–ï–†–ö–ê –ó–ê–ü–£–©–ï–ù–ù–û–ì–û –ü–†–û–¶–ï–°–°–ê ==="
            sleep 2  # –î–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å—É –≤—Ä–µ–º—è –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è
            
            # –°—Ä–∞–∑—É –ø—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫
            echo "=== –ü–†–û–í–ï–†–ö–ê –õ–û–ì–û–í –°–†–ê–ó–£ –ü–û–°–õ–ï –ó–ê–ü–£–°–ö–ê ==="
            if [ -f "bot.log" ]; then
              LOG_SIZE=$(stat -c%s bot.log 2>/dev/null || stat -f%z bot.log 2>/dev/null || echo "0")
              if [ "$LOG_SIZE" -gt 0 ]; then
                echo "bot.log exists and has content ($LOG_SIZE bytes)"
                echo ""
                echo "=== Last 50 lines of bot.log ==="
                tail -50 bot.log || cat bot.log
                echo ""
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏
                if grep -qiE "error|panic|fatal|failed" bot.log; then
                  echo "‚ö†Ô∏è  WARNING: Found error messages in bot.log!"
                  echo "=== ERROR SUMMARY ==="
                  grep -iE "error|panic|fatal|failed" bot.log | head -15
                  echo ""
                  
                  # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ü–µ—Å—Å
                  if ! pgrep -f "$PROC_PATTERN" > /dev/null; then
                    echo "‚ùå Process has crashed! Checking detailed logs..."
                    echo "=== FULL bot.log ==="
                    cat bot.log || tail -200 bot.log
                    echo "=== END bot.log ==="
                    exit 1
                  fi
                fi
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω—ã–π –∑–∞–ø—É—Å–∫ –≤ –ª–æ–≥–∞—Ö
                if grep -qiE "starting drupal reminder bot|authorized on account|bot is ready" bot.log; then
                  echo "‚úÖ Found startup success indicators in logs"
                fi
              else
                echo "bot.log exists but is empty - process may still be initializing"
              fi
            else
              echo "‚ö†Ô∏è  bot.log not found yet - process may still be starting"
            fi
            echo ""
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º PID –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            if [ -z "$NEW_PID" ]; then
              NEW_PID=$(pgrep -f "$PROC_PATTERN" | head -1)
            fi
            
            if [ -n "$NEW_PID" ] && kill -0 "$NEW_PID" 2>/dev/null; then
              PID=$NEW_PID
              echo "‚úÖ Process found with PID: $PID"
              echo ""
              echo "Process details:"
              ps aux | grep -E "[d]rupal-reminder-bot" || true
              echo ""
              echo "Process tree:"
              pstree -p $PID 2>/dev/null || ps -ef | grep -E "[d]rupal-reminder-bot" || true
              echo ""
              echo "Process status from /proc:"
              if [ -d "/proc/$PID" ]; then
                echo "  State: $(cat /proc/$PID/stat | awk '{print $3}')"
                echo "  PPID: $(cat /proc/$PID/stat | awk '{print $4}')"
                echo "  Session ID: $(cat /proc/$PID/sessionid 2>/dev/null || echo 'N/A')"
                echo "  TTY: $(readlink /proc/$PID/fd/0 2>/dev/null || echo 'N/A')"
                echo "  Working directory: $(readlink /proc/$PID/cwd 2>/dev/null || echo 'N/A')"
                echo "  Command line: $(cat /proc/$PID/cmdline 2>/dev/null | tr '\0' ' ' || echo 'N/A')"
              else
                echo "  /proc/$PID not found"
              fi
              echo ""
              
              # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–æ–≤
              echo "=== –ü–†–û–í–ï–†–ö–ê –õ–û–ì–û–í ==="
              if [ -f "bot.log" ]; then
                echo "‚úÖ bot.log exists"
                echo "File size: $(stat -c%s bot.log 2>/dev/null || stat -f%z bot.log 2>/dev/null) bytes"
                echo "Last 50 lines of bot.log:"
                tail -50 bot.log || echo "Failed to read bot.log"
              else
                echo "‚ö†Ô∏è  bot.log not found yet"
              fi
              echo ""
              
              # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
              echo "=== –ü–û–í–¢–û–†–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ß–ï–†–ï–ó 3 –°–ï–ö–£–ù–î–´ ==="
              sleep 3
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –≤—Å–µ –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
              CURRENT_PID=$(pgrep -f "$PROC_PATTERN" | head -1)
              if [ -n "$CURRENT_PID" ] && kill -0 "$CURRENT_PID" 2>/dev/null; then
                echo "‚úÖ Process is still running (PID: $CURRENT_PID)"
                if [ "$PID" != "$CURRENT_PID" ]; then
                  echo "‚ö†Ô∏è  WARNING: PID changed from $PID to $CURRENT_PID (process may have restarted)"
                fi
                echo ""
                echo "Final process status:"
                ps aux | grep -E "[d]rupal-reminder-bot" || true
                echo ""
                echo "‚úÖ‚úÖ‚úÖ DEPLOYMENT SUCCESSFUL ‚úÖ‚úÖ‚úÖ"
              else
                echo "‚ùå‚ùå‚ùå PROCESS DISAPPEARED AFTER INITIAL CHECK ‚ùå‚ùå‚ùå"
                echo ""
                if [ -n "$PID" ]; then
                  echo "Original PID was: $PID"
                  echo "Checking if process with PID $PID still exists:"
                  if kill -0 "$PID" 2>/dev/null; then
                    echo "‚ö†Ô∏è  Process with PID $PID still exists"
                  else
                    echo "‚úÖ Process with PID $PID is gone (as expected if it crashed)"
                  fi
                else
                  echo "PID was not set"
                fi
                echo ""
                echo "Checking for any drupal-reminder-bot processes:"
                ps aux | grep drupal-reminder-bot || echo "No processes found"
                echo ""
                echo "Checking system logs:"
                dmesg | tail -20 | grep -i "drupal\|killed\|sigterm" || echo "No relevant dmesg entries"
                echo ""
                echo "=== DETAILED bot.log ANALYSIS ==="
                if [ -f "bot.log" ]; then
                  LOG_SIZE=$(stat -c%s bot.log 2>/dev/null || stat -f%z bot.log 2>/dev/null || echo "0")
                  echo "bot.log size: $LOG_SIZE bytes"
                  if [ "$LOG_SIZE" -gt 0 ]; then
                    echo "=== FULL bot.log ==="
                    cat bot.log || tail -200 bot.log
                    echo "=== END bot.log ==="
                    echo ""
                    echo "=== ERROR SUMMARY ==="
                    grep -i "error\|panic\|fatal\|failed" bot.log | head -20 || echo "No explicit errors found"
                  else
                    echo "bot.log is empty - process may have crashed before writing logs"
                  fi
                else
                  echo "bot.log not found - process may have crashed before creating log file"
                fi
                echo ""
                echo "=== TESTING BINARY DIRECTLY ==="
                echo "Attempting to run binary with timeout to capture startup errors:"
                timeout 5 ./drupal-reminder-bot 2>&1 || echo "Binary execution failed or timed out"
                echo ""
                echo "Checking for core dumps:"
                ls -lah core* 2>/dev/null || echo "No core dumps found"
                echo ""
                echo "Checking file permissions and ownership:"
                ls -lah ./drupal-reminder-bot
                echo ""
                echo "Checking if binary is executable:"
                test -x ./drupal-reminder-bot && echo "‚úÖ Binary is executable" || echo "‚ùå Binary is NOT executable"
                echo ""
                echo "Checking binary file type:"
                file ./drupal-reminder-bot
                echo ""
                exit 1
              fi
            else
              echo "‚ùå‚ùå‚ùå PROCESS NOT FOUND AFTER STARTUP ‚ùå‚ùå‚ùå"
              echo ""
              echo "Start method was: $START_METHOD"
              echo ""
              echo "Checking all processes:"
              ps aux | head -20
              echo ""
              echo "Checking for any drupal-reminder-bot processes:"
              ps aux | grep drupal-reminder-bot || echo "No processes found"
              echo ""
              if [ "$START_METHOD" = "screen" ]; then
                echo "Screen sessions:"
                screen -list || true
              elif [ "$START_METHOD" = "tmux" ]; then
                echo "Tmux sessions:"
                tmux list-sessions || true
              fi
              echo ""
              echo "=== DETAILED bot.log ANALYSIS ==="
              if [ -f "bot.log" ]; then
                LOG_SIZE=$(stat -c%s bot.log 2>/dev/null || stat -f%z bot.log 2>/dev/null || echo "0")
                echo "bot.log size: $LOG_SIZE bytes"
                if [ "$LOG_SIZE" -gt 0 ]; then
                  echo "=== FULL bot.log ==="
                  cat bot.log || tail -200 bot.log
                  echo "=== END bot.log ==="
                  echo ""
                  echo "=== ERROR SUMMARY ==="
                  grep -i "error\|panic\|fatal\|failed" bot.log | head -20 || echo "No explicit errors found"
                else
                  echo "bot.log is empty - process may have crashed before writing logs"
                fi
              else
                echo "bot.log not found - process may have crashed before creating log file"
                echo "Checking if file was created:"
                ls -lah bot.log 2>&1 || true
              fi
              echo ""
              echo "=== TESTING BINARY DIRECTLY ==="
              echo "Attempting to run binary with timeout to capture startup errors:"
              timeout 10 ./drupal-reminder-bot 2>&1 || echo "Binary execution failed or timed out"
              echo ""
              echo "Checking system resources:"
              df -h . || true
              free -h || true
              echo ""
              echo "Checking file permissions and ownership:"
              ls -lah ./drupal-reminder-bot
              echo ""
              echo "Checking if binary is executable:"
              test -x ./drupal-reminder-bot && echo "‚úÖ Binary is executable" || echo "‚ùå Binary is NOT executable"
              echo ""
              echo "Checking binary file type:"
              file ./drupal-reminder-bot
              echo ""
              echo "Checking .env file (if exists):"
              if [ -f ".env" ]; then
                echo "‚úÖ .env file exists"
                echo "File size: $(stat -c%s .env 2>/dev/null || stat -f%z .env 2>/dev/null) bytes"
                echo "Checking for required variables (without showing values):"
                grep -q "TELEGRAM_BOT_TOKEN" .env && echo "‚úÖ TELEGRAM_BOT_TOKEN is present" || echo "‚ùå TELEGRAM_BOT_TOKEN is MISSING"
              else
                echo "‚ùå .env file NOT FOUND"
                echo "This is likely the cause of the failure!"
              fi
              echo ""
              exit 1
            fi
            
            echo ""
            echo "=========================================="
            echo "=== –î–ï–ü–õ–û–ô –ó–ê–í–ï–†–®–ï–ù ==="
            echo "=========================================="
